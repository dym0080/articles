>说明：本系列是作为个人知识收集与总结，方便自己随时查看，建立个人知识库，很多资源都是来源网络。

## 不要使用with
虽然 with 能给开发者带来便利，但它可能会影响性能。with 会在引用变量时为脚本引擎构造一个额外的作用域。仅此，会造成少许性能下降。然而，编译期并不能获知这个作用域的内容，所以编译器不会像优化普通的作用域(比如由函数创建的作用域)那样优化它。

有更多的方法给开发者提供使得，比如使用一个普通变量来引用对象，然后通过这个变量来访问其属性。显然只有当属性不是字面类型，比如字符串或布尔型的时候，才能这样做。

>提示：with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。——来自[w3school](http://www.w3school.com.cn/js/pro_js_statements_with.asp)的建议

## 避免使用 eval 或 Function 构造器
每次进行 eval 或调用 Function 构造器，脚本引擎都会启动一些机制来将字符串形式的源代码转换为可执行的代码。这通常会严重影响性能 —— 比如说，直接调用函数的性能是它的 100 倍。

eval 函数尤其糟糕，因为 eval 无法预知传递给它的字符串的内容。代码是在调用 eval 的上下文档中解释，这就意味着编译器无法优化相关上下文，就会留给浏览器很多需要在运行时解释的内容。这就造成了额外的性能影响。

Function 构造器比 eval 要好一点，因为它不影响周围代码的使用，但它仍然相当缓慢。

## 尽量不用全局变量
创建临时变量很简单，所以很诱人。然而，因为某些原因，它可能会让脚本运行缓慢。

首先，如果代码在函数或另一个作用域中引用全局变量，脚本引擎会依次通过每个作用域直到全局作用域。局部变量找起来会快得多。

全局作用域中的变量存在于脚本的整个生命周期。而局部变量会在离开局部作用域的时候被销毁，它们占用的内存可以被垃圾收集器回收。

最后，全局作用域由 `window `对象共享，也就是说它本质上是两个作用域而不是一个。在全局作用域中，变量总是通过其名称来定位，而不是像局部变量那样经过优化，通过预定义的索引来定位。这最终导致脚本引擎需要花更多时间来找到全局变量。

函数通常也在全局作用域中创建。因此一个函数调另一个函数，另一个函数再接着调其它函数，如此深入下去，脚本引擎就会不断增加往回定位全局变量的时间。
## 注意对象的隐式转换
字面量，比如字符中、数、和布尔值，在 ECMAScript 中有两种表现形式。它们每种类型都可以作为值创建，也可以作为对象创建。比如，`var oString = 'some content';` 创建了一个字符串值，而` var oString = new String('some content'); `创建了等价的字符串对象。

所有属性和方法都是在字符串对象而不是值上定义的。如果你对字符串值调用属性和方法，ECMAScript 引擎必须用相同的字符串值隐式地创建一个新的字符串对象，然后才能调用方法。这个对象仅用于这一个需求，如果下次再对字符串值调用某个方法，会再次类似地创建字符串对象。

下面的示例的让脚本引擎创建 21 个新的字符串对象。每次访问 `length` 属性和每次调用 `charAt` 方法的时候都会创建对象：
``` js
var s = '0123456789';for(var i = 0; i < s.length; i++) {
  s.charAt(i);
}
```
下面的示例与上面那个示例等价，但只创建了一个对象，它的执行结果更好：
``` js
var s = new String('0123456789');for(var i = 0; i < s.length; i++) {
  s.charAt(i);
}
```
如果你的代码经常调用字面量值的方法，你就应该考虑把它们转换为对象，就像上面的例子那样。

## 基本运算比调用函数更快
虽然普通代码中不需要太注意，但在要求性能的循环和函数中还有办法提高性能——把函数调用替换为等价的基本调用。比如对数组调用 push 方法就会比直接通过数组的尾部索引添加元素更慢。再比如对于 Math 对象来说，多数时候，简单的数学计算会比调用方法更恰当。
```js
var min = Math.min(a,b);
A.push(v);
```
下面的代码做了同样的事情，但性能更好：
```js
var min = a < b ? a : b;
A[A.length] = v;
```
