## 可迭代对象

使用 `iter` 内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的`__iter__` 方法，那么对象就是可迭代的。序列都可以迭代，是因为实现了 `__getitem__ `方法，而且其参数是从零开始的索引，这种对象也可以迭代。

可以使用 `for` 循环遍历一个可迭代对象：
```python
>>> s = 'ABC'
>>> for char in s:
	print(char)
	
A
B
C
```
如果没有 `for` 语句，不得不使用 `while` 循环模拟，要像下面这样写：

```python
>>> s = 'ABC'
>>> it = iter(s)
>>> while True:
	try:
		print(next(it))
	except StopIteration:
		del it
		break

	
A
B
C
```

我们要明确可迭代的对象和迭代器之间的关系：Python 从可迭代的对象中获取迭代器。

## 迭代器

迭代器是这样的对象：实现了无参数的 `__next__` 方法，返回序列中的下一个元素；如果没有元素了，那么抛出 StopIteration 异常。Python 中的迭代器还实现了 `__iter__` 方法，因此迭代器也可以迭代。

标准的迭代器接口有两个方法：

- `__next__`：返回下一个可用的元素，如果没有元素了，抛出 StopIteration 异常。
- `__iter__`：返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如在 for 循环中。


构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。要知道，可迭代的对象有个 `__iter__` 方法，每次都实例化一个新的迭代器；而迭代器要实现 `__next__` 方法，返回单个元素，此外还要实现 `__iter__ `方法，返回迭代器本身。因此，**迭代器可以迭代，但是可迭代的对象不是迭代器**。

可迭代的对象一定不能是自身的迭代器。也就是说，可迭代的对象必须实现`__iter__` 方法，但不能实现 `__next__` 方法。

## 生成器

只要 Python 函数的定义体中有 `yield` 关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。

普通的函数与生成器函数在句法上唯一的区别是，在后者的定义体中有 `yield` 关键字。

下面以一个特别简单的函数说明生成器的行为：

```python
>>> def gen_123():
	yield 1
	yield 2
	yield 3
	
>>> gen_123
<function gen_123 at 0x000001F1621880D8>
>>> gen_123()
<generator object gen_123 at 0x000001F162122D48>
>>> for i in gen_123():
	print(i)
	
1
2
3
>>> g = gen_123()
>>> next(g)
1
>>> next(g)
2
>>> next(g)
3
>>> next(g)
Traceback (most recent call last):
  File "<pyshell#27>", line 1, in <module>
    next(g)
StopIteration
```
生成器函数会创建一个生成器对象，包装生成器函数的定义体。把生成器传给`next(...)` 函数时，生成器函数会向前，执行函数定义体中的下一个 `yield` 语句，返回产出的值，并在函数定义体的当前位置暂停。最终，函数的定义体返回时，外层的生成器对象会抛出 StopIteration 异常——这一点与迭代器协议一致。

## 生成器表达式

生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，**如果列表推导是制造列表的工厂，那么生成器表达式就是制造生成器的工厂**。

生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生器表达式更便利。

根据我的经验，选择使用哪种句法很容易判断：如果生成器表达式要分成多行写，我倾向于定义生成器函数，以便提高可读性。此外，生成器函数有名称，因此可以重用。

## 迭代器与生成器之间的关系

第一方面是接口。Python 的迭代器协议定义了两个方法：`__next__` 和 `__iter__`。生成器对象实现了这两个方法，因此从这方面来看，所有生成器都是迭代器

第二方面是实现方式。从这个角度来看，生成器这种 Python 语言结构可以使用两种方式编写：含有 `yield` 关键字的函数，或者生成器表达式。调用生成器函数或者执行生成器表达式得到的生成器对象属于语言内部的 `GeneratorType` 类型。从这方面来看，所有**生成器都是迭代器，但迭代器不一定是生成器**。

第三方面是概念。迭代器用于遍历集合，从中产出元素,调用 `next(it)` 时，迭代器不能修改从数据源中读取的值，只能原封不动地产出值。而生成器可能无需遍历集合就能生成值，例如 `range` 函数。即便依附了集合，生成器不仅能产出集合中的元素，还可能会产出派生自元素的其他值。