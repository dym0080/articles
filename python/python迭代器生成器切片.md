
在迭代器和生成器上做切片操作最好的方法是使用函数 `itertools.islice()`

```python
>>> g = (x for x in range(0,100))  # <1>
>>> g
<generator object <genexpr> at 0x000001F1621A7048>
>>> g[10,20]  # <2>
Traceback (most recent call last):
  File "<pyshell#52>", line 1, in <module>
    g[10,20]
TypeError: 'generator' object is not subscriptable
>>> next(g)
0
>>> next(g)
1
>>> next(g) # <3>
2
>>> import itertools
>>> for x in itertools.islice(g, 10, 20): #<4>
	      print(x)
	
13
14
15
16
17
18
19
20
21
22
>>> next(g) #<5>
23
>>> next(g)
24
>>> 
```

- <1> 使用生成器表达式`[1]`产生一个的生成器 `g`。
- <2> 生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引),所以这里会报错。
- <3> 调用三次 `next` 函数到值 `2` 的输出
- <4> 函数 `islice()` 返回一个可以生成指定元素的迭代器，它通过遍历并丢弃（由于前面已经用掉了三个值，所以遍历时从 `3` 开始，并且遍历时丢弃了 `3`到 `12` 的值）直到切片开始索引位置的所有元素。 然后才开始一个个的返回元素，并直到切片结束索引位置。
- <5> 这里要着重强调的一点是 `islice()` 会消耗掉传入的迭代器中的数据。 必须考虑到迭代器是不可逆的这个事实。因此再次掉用 `next` 的时候值是 `23`，而不是 `3`。

> [1] 生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，**如果列表推导是制造列表的工厂，那么生成器表达式就是制造生成器的工厂**。
生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生器表达式更便利。